---
layout:     post
title:      "DSO代码阅读"
subtitle:   " \"博学之审问之慎思之明辨之笃行之。\""
date:       2017-2-28 21：19
author:     "Bobin"
tags:
    - SLAM
---


最近再看OSO的代码，这里总结一下。
这里首先介绍一些变量的名称便于之后的理解。
# 变量及函数名称简介
## FrameHessian
1. EFFrame其中的EF表示的是Energy Function，类似的是EFPoint。这两个类分别被FrameHessian和PointHessian调用。
2. AffLight表示光度模型和曝光量的两个参数a，曝光量。b光度学模型的偏置。
3. trackNewCoarse 中关心的内容是三帧分别是slast、sprelast、lastF。lastF表示最近的参考帧coarseTracker->lastRef。slast、sprelast表示allFrameHistory中的最新的两帧图像。
4. allFrameHistory的构造，他是在addActiveFrame中添加的，先构造空的结构，然后把图像数据丢进去，使用makeImage函数。
5. makeImages 构造dI，梯度图像。
6. coarseTracker->lastRef在coarseTracker类的成员函数setCoarseTrackingRef中设置，frameHessians.back出一帧。frameHessians在makeKeyFrame中pushback。

Hessian矩阵是8X8的，其中SE3为6个，光度为2个。


## Tracking new coarse
该函数被makeKeyFrame和makeNonKeyFrame被调用。两者在mappingLoop和makeNonKeyFrame中分情况对立出现。
该函数的主要内容是
1. push many tries，这些tries是根据上一次的运动量做的估计，分别在上一帧的运动上上增加了许多微调，单倍上次运动，双倍运动，上次运动的一半。还有xyz三个轴分别扰动0.05。
2. for every tries, do trackNewestCoarse。其中trackNewestCoarse做的事有
  - 根据tries计算对应残差
  - 根据根据残差和梯度计算雅克比矩阵
  - 迭代优化位姿


## pixelSelector and pixelSelector2
1. 两者被被CoarseInitializer中的setFirst调用。
2. 另外后者还被makemaps调用，出现在trackNewCoarse中。

traceNewCoarse 的主要作用是给被跟踪的点分类。
## 边缘化
1. schur操作中边缘话关键帧位于函数ef-marginalizeFrame()
2. schur操作中边缘话路标点位于函数ef-marginalizePointF()



# 主要流程
1. 读入图像，FullSystem 执行 active frame
2. FullSystem run dilver tracked frame

## FullSystem->active frame
1. Initialization
2. Tracking frame in first frame, Initialization complete.
3. Tracking new coarse.


## dilver tracker frame
1. display image
2. make key frame


## dilver tracker frame
1. display image
2. make key frame


### make kf
1. trace new coarse
2. flag frame for marginalization
3. add frame to Struct
4. add new residuals for old points
5. active point in marginalization
6. optimization
7. remove outliers
8. get nulll space
9. marginalize points

## marginalize frame
1. ef-> marginalize frame
  -
2. for every frame in our the buffer
  - for evert points in the frame
    - get residuals
    - statistics_numForceDroppedResFwd
    - ef->dropResidual(r->efResidual);
    -

![流程图](/img/dso.jpg)

## 关于optimization
这里主要包含四个类分别是EFResidual、EFFrame、EFPoint以及EFFunctional。
这个四个类的主要EFResidual主要负责负责计算残差，成员函数包括
void takeDataF();
该函数用来计算JI_JI_Jd，EFFrame、EFPoint都有这个函数
void fixLinearizationF(EnergyFunctional \*ef);
用来计算compute Jp*delta
这三个类主要提供了成员变量，这些数据的操作在EFFunctional中，四个类的成员变量如表所示
![](assets/2017-2-28-dso-slam-8ced5.png)
他们之间的关系如下图所示
![](/img/optimization.png)
如图所示EFPoint中包含了很多Hcd以及bd这些被由AccumulatorXX 或者AccumulatorX构造的累计器累计，RawResidualJacobian构造了许多雅克比项，这些由accSSE_top_L和accSSE_top_L计算。上述是线性化中的一些部分。
线性化完毕之后计算L Energy和M energy两者之间的不同在在于前者使用了激活点和线性化点的Hessian，后者计算了边缘化，schur complement操作之后的Hessian。如下图所示。
![](/img/optimization1.png)
其中线性化Hessian，为什么Hessian在程序中被称为能量呢？因为原始残差表达式已经linearize过了。在计算JI^T * r 和 Jab^T * r中，激活点的r只是残差，而线性化能量是通过雅克比矩阵计算，这里体现relinearize。
